# A. Простое двоичное дерево поиска

|                                |                   |
| ------------------------------ | ----------------- |
| ограничение по времени на тест | 2 секунды         |
| ограничение по памяти на тест  | 512 мегабайт      |
| ввод                           | стандартный ввод  |
| вывод                          | стандартный вывод |

Реализуйте простое двоичное дерево поиска.

## Входные данные
Входной файл содержит описание операций с деревом, их количество не превышает 100. В каждой строке находится одна из следующих операций:

- `insert x` — добавить в дерево ключ `x`. Если ключ `x` есть в дереве, то ничего делать не надо;
- `delete x` — удалить из дерева ключ `x`. Если ключа `x` в дереве нет, то ничего делать не надо;
- `exists x` — если ключ `x` есть в дереве выведите `true`, если нет `false`;
- `next x` — выведите минимальный элемент в дереве, строго больший `x`, или none если такого нет;
- `prev x` — выведите максимальный элемент в дереве, строго меньший `x`, или none если такого нет.

В дерево помещаются и извлекаются только целые числа, не превышающие по модулю $10^9$.

## Выходные данные
Выведите последовательно результат выполнения всех операций `exists`, `next`, `prev`. Следуйте формату выходного файла из примера.

### Пример
входные данные
```
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```
выходные данные
```
true
false
5
3
none
3
```

### Примечание
Реализуйте обычное дерево поиска.




# B. Сбалансированное двоичное дерево поиска

|                                |                   |
| ------------------------------ | ----------------- |
| ограничение по времени на тест | 2 секунды         |
| ограничение по памяти на тест  | 512 мегабайт      |
| ввод                           | стандартный ввод  |
| вывод                          | стандартный вывод |

Реализуйте сбалансированное двоичное дерево поиска.

## Входные данные
Входной файл содержит описание операций с деревом, их количество не превышает $10^5$. В каждой строке находится одна из следующих операций:

- `insert x` — добавить в дерево ключ `x`. Если ключ `x` есть в дереве, то ничего делать не надо;
- `delete x` — удалить из дерева ключ `x`. Если ключа `x` в дереве нет, то ничего делать не надо;
- `exists x` — если ключ `x` есть в дереве выведите `true`, если нет `false`;
- `next x` — выведите минимальный элемент в дереве, строго больший `x`, или «none» если такого нет;
- `prev x` — выведите максимальный элемент в дереве, строго меньший `x`, или «none» если такого нет.

В дерево помещаются и извлекаются только целые числа, не превышающие по модулю $10^9$.

## Выходные данные
Выведите последовательно результат выполнения всех операций `exists`, `next`, `prev`. Следуйте формату выходного файла из примера.

### Пример
входные данные
```
insert 2
insert 5
insert 3
exists 2
exists 4
next 4
prev 4
delete 5
next 4
prev 4
```
выходные данные
```
true
false
5
3
none
3
```

### Примечание
Реализуйте AVL-дерево.




# C. K-й максимум

|                                |                   |
| ------------------------------ | ----------------- |
| ограничение по времени на тест | 2 секунды         |
| ограничение по памяти на тест  | 512 мегабайт      |
| ввод                           | стандартный ввод  |
| вывод                          | стандартный вывод |

Напишите программу, реализующую структуру данных, позволяющую добавлять и удалять элементы, а также находить k-й максимум.

## Входные данные
Первая строка входного файла содержит натуральное число $n$ — количество команд ( $n \leq 10^5$ ). Последующие $n$ строк содержат по одной команде каждая. Команда записывается в виде двух чисел $c_i$ и $k_i$ — тип и аргумент команды соответственно ( $|k_i| \leq 10^9$ ). 
Поддерживаемые команды:

- `1`: Добавить элемент с ключом $k_i$.
- `0`: Найти и вывести $k_i$-й максимум.
- `-1`: Удалить элемент с ключом $k_i$.

Гарантируется, что в процессе работы в структуре не требуется хранить элементы с равными ключами или удалять несуществующие элементы.
Также гарантируется, что при запросе $k_i$-го максимума, он существует.

## Выходные данные
Для каждой команды нулевого типа в выходной файл должна быть выведена строка, содержащая единственное число — $k_i$-й максимум.

### Пример
входные данные
```
11
1 5
1 3
1 7
0 1
0 2
0 3
-1 5
1 10
0 1
0 2
0 3
```
выходные данные
```
7
5
3
10
7
3
```

### Примечание
В вершине можно хранить вспомогательную информацию, например, число вершин в поддереве.




# D. И снова сумма

|                                |                   |
| ------------------------------ | ----------------- |
| ограничение по времени на тест | 3 секунды         |
| ограничение по памяти на тест  | 256 мегабайт      |
| ввод                           | стандартный ввод  |
| вывод                          | стандартный вывод |

Реализуйте структуру данных, которая поддерживает множество $S$ целых чисел, с котором разрешается производить следующие операции:

 - `add(i)` добавить в множество $S$ число $i$ (если он там уже есть, то множество не меняется).
 - `sum(l, r)` вывести сумму всех элементов $x$ из $S$, которые удовлетворяют неравенству $l \leq x \leq r$.

## Входные данные
Исходно множество $S$ пусто. Первая строка входного файла содержит $n$ — количество операций ( $1 \leq n \leq 300 000$ ). 
Следующие $n$ строк содержат операции. Каждая операция имеет вид либо `+ i`, либо `? l r`. Операция `? l r` задает запрос `sum(l, r)`.

Если операция `+ i` идет во входном файле в начале или после другой операции `+`, то она задает операцию `add(i)`. 
Если же она идет после запроса `?`, и результат этого запроса был `y`, то выполняется операция `add((i+y) mod 10^9)`.

Во всех запросах и операциях добавления параметры лежат в интервале от $0$ до $10^9$.

## Выходные данные
Для каждого запроса выведите одно число — ответ на запрос.

### Пример
входные данные
```
6
+ 1
+ 3
+ 3
? 2 4
+ 1
? 2 4
```
выходные данные
```
3
7
```

### Примечание
Декартово дерево использовать нельзя.
