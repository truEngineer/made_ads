# A. Разделение выражения на лексемы

|                                |                   |
| ------------------------------ | ----------------- |
| ограничение по времени на тест | 1 секунда         |
| ограничение по памяти на тест  | 256 мегабайт      |
| ввод                           | стандартный ввод  |
| вывод                          | стандартный вывод |

Задано числовое выражение, заканчивающееся точкой. Необходимо разбить его на лексемы и вывести каждую на новой строке. 
Гарантируется, что исходное выражение корректно.

В выражении могут встречаться знаки сложения, вычитания, умножения и скобки. Приоритет операций стандартный. 
Все числа в выражении целые и принадлежат диапазону `LongInt`.

## Входные данные
Первая строка содержит заданное выражение. Его длина не превосходит 100 знаков. 
Гарантируется, что выражение заканчивается точкой.

## Выходные данные
Выведите все встречающиеся лексемы выражения по порядку и ровно по одной на каждой строке.

### Пример
входные данные
```
1+(2*2-3).
```
выходные данные
```
1
+
(
2
*
2
-
3
)
```

### Примечание
Необходимо написать лексер.




# B. Значение выражения

|                                |                   |
| ------------------------------ | ----------------- |
| ограничение по времени на тест | 2 секунды         |
| ограничение по памяти на тест  | 64 мегабайта      |
| ввод                           | стандартный ввод  |
| вывод                          | стандартный вывод |

Задано числовое выражение, заканчивающееся точкой. Необходимо посчитать его значение или сказать, что оно содержит ошибку. 

В выражении могут встречаться знаки сложения, вычитания, умножения и скобки. Приоритет операций стандартный. Все числа в выражении целые и принадлежат диапазону `LongInt`. Также гарантируется, что все промежуточные вычисления умещаются в этот тип. Унарный плюс и унарный минус в выражении встречаться не могут, как и два знака подряд.

## Входные данные
Первая строка содержит заданное выражение. Его длина не превосходит 100 знаков. 
Гарантируется, что выражение заканчивается точкой.

## Выходные данные
Выведите значение этого выражения или слово `WRONG`, если значение не определено.

### Пример
входные данные
```
1+(2*2-3).
```
выходные данные
```
2
```
входные данные
```
1+a+1.
```
выходные данные
```
WRONG
```

### Примечание
Используя лексер, добавляем парсер, получаем дерево разбора, из которого вычисляем значение.




# С. Значение выражения

|                                |                   |
| ------------------------------ | ----------------- |
| ограничение по времени на тест | 2 секунды         |
| ограничение по памяти на тест  | 64 мегабайта      |
| ввод                           | стандартный ввод  |
| вывод                          | стандартный вывод |

Задано новогоднее выражение, заканчивающееся точкой. Необходимо посчитать его значение или сказать, что оно содержит ошибку. В новогоднем выражении могут встречаться знаки сложения, вычитания, умножения и скобки, константы `Ded Moroz`, `Moroz` и `Snegurochka`, а также вызов функции `Podarok`, которая принимает одно число на вход и возвращает его, увеличенное на 5, если оно было положительно, или возвращает его модуль, если оно было меньше либо равно 0. Приоритет операций стандартный. Все числа в выражении целые и принадлежат диапазону `LongInt`. Также гарантируется, что все промежуточные вычисления умещаются в этот тип.

## Входные данные
Первая строка содержит заданное выражение. Его длина не превосходит 200 знаков. Гарантируется, что выражение заканчивается точкой.

Значения констант:
- `Ded Moroz = 2020`
- `Moroz = -30`
- `Snegurochka = 10`

## Выходные данные
Выведите значение этого новогоднего выражения или слово `WRONG`, если значение не определено.

### Пример
входные данные
```
Podarok(Moroz-Ded Moroz)*2.
```
выходные данные
```
4100
```
входные данные
```
Snegurochka-30.
```
выходные данные
```
-20
```

### Примечание
Расширяем грамматику с учетом трех переменных и одной новой функции.




# D. Chaotic Evil

|                                |                   |
| ------------------------------ | ----------------- |
| ограничение по времени на тест | 2 секунды         |
| ограничение по памяти на тест  | 256 мегабайт      |
| ввод                           | стандартный ввод  |
| вывод                          | стандартный вывод |

Рассмотрим язык, чуть более похожий на Си, чем в прошлый раз. В нём есть следующие простые типы:
| Имя типа                                                          | Размер  |
|:----------------------------------------------------------------- |:------- |
| bool                                                              | 1 байт  |
| char, signed char                                                 | 1 байт  |
| unsigned char                                                     |	1 байт  |
| short, signed short, short int, signed short int                  |	2 байта |
| unsigned short, unsigned short int	                              | 2 байта |
| int, signed, signed int                                           | 4 байта |
| unsigned, unsigned int	                                          | 4 байта |
| long, signed long, long int, signed long int	                    | 8 байт  |
| unsigned long, unsigned long int	                                | 8 байт  |
| long long, signed long long, long long int, signed long long int	| 8 байт  |
| unsigned long long, unsigned long long int	                      | 8 байт  |

В языке есть оператор `sizeof`, который позволяет узнать размер любого типа в байтах. К примеру, `sizeof(int)` равен четырём.

В языке есть оператор `alignof`, который позволяет узнать выравнивание любого типа в байтах. Адрес переменной какого-то типа $T$ в памяти должен делиться на `alignof(T)`. `sizeof(T)` всегда делится на `alignof(T)`. `alignof(T)` всегда является неотрицательной целой степенью двойки. Для простых типов, `alignof(T) == sizeof(T)`.

В языке есть массивы фиксированной длины, состоящие из элементов одного типа. Массив из $n$ элементов, каждый типа $T$ обозначается как `T[n]`. `sizeof(T[n])` равен `sizeof(T) * n`. К примеру, `sizeof(short[13])` равен 26, так как размер типа `short` — два байта, а в массиве 13 элементов. `alignof(T[n])` равен `alignof(T)`. Поддержки многомерных массивов в языке нет.

В языке есть структуры — композитные типы, позволяющие объединять фиксированное количество переменных (полей) разных типов в одну. Пусть в структуре $n > 0$ полей $f_1, \dots, f_n$ типов $T_1, \ldots, T_n$. Пусть эта структура лежит в памяти по адресу $a$. Тогда должны выполняться следующие дополнительные условия:

- Адрес $f_1$ равен $a$.
- Для $k = 2, \ldots, n$, Адрес $f_k$ больше адреса $f_k - 1$.
- Поля не могут пересекаться
- Как и для самой структуры, так и для всех её полей должны выполнятся стандартные правила выравнивания.
- Выравнивание структуры — максимум из выравниваний её полей.
- Размер структуры не меньше суммы размеров её полей.
- Размер структуры — минимальный из размеров, удовлетворяющий всем условиям.
- Вам предлагается написать программу, вычисляющую `sizeof` и `alignof` для произвольных типов.

## Входные данные
Во вводе записаны команды, `typedef`, `sizeof` или `alignof`.

Команда `typedef` объявляет новый тип. Например, `typedef eightbytes unsigned char[8]` объявляет новый тип `eightbytes`, который представляет собой массив из восьми `unsigned char`. `typedef` может также объявлять структуры. Смотрите примеры. Гарантируется, что имя нового типа — непустая строка из латинских букв длиной не более 32 символов, кроме `bool`, `char`, `signed`, `unsigned`, `short`, `int`, `long`, `struct`, `typedef`, `sizeof`, `alignof`.

Гарантируется, что объявления новых типов имеют уникальные имена.

Команды `sizeof` и `alignof` печатают на экран на новой строке размер и выравнивание типа соответственно. Например, `sizeof unsigned char[8]` напечатает на экран 8.

Гарантируется, что размер входных данных по объёму не превосходит одного мегабайта. Размер каждого используемого типа не превосходит одного эксабайта.

## Выходные данные
Для каждой команды `sizeof` или `alignof` в отдельной строке напечатайте результат выполнения соответствующего оператора.

### Пример
входные данные
```
typedef eightbytes unsigned char[8]
sizeof eightbytes
alignof eightbytes
```
выходные данные
```
8
1
```
входные данные
```
typedef verylong struct {
long[2];
unsigned short int[4];
}
sizeof verylong
alignof verylong
```
выходные данные
```
24
8
```
входные данные
```
typedef verylong struct {
long[2];
unsigned short int[4];
}
typedef evenlonger struct {
verylong[4];
}
sizeof evenlonger
alignof evenlonger
typedef arr evenlonger[123]
sizeof arr
alignof arr

```
выходные данные
```
96
8
11808
8
```

### Примечание
Задача на осознание языка, придумывание грамматики и последующую обработку текста на этом языке.
